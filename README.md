# Транспортный справочник
Программа для хранения автобусов и остановок. Загружает информацию о маршрутах через JSON запрос и хранит ее на жестком диске в виде бинарного файла. Посредством JSON-запроса позволяет получить информацию об автобусах и остановках, построить маршрут, сформировать графическое представление транспортной схемы в формате SVG.

### В проекте используются
![C++17](https://img.shields.io/badge/C++17-1F2023?style=flat-square)
![STL](https://img.shields.io/badge/STL-1F2023?style=flat-square)
![CMake](https://img.shields.io/badge/CMake-1F2023?style=flat-square)
![Protobuf3](https://img.shields.io/badge/Protobuf-1F2023?style=flat-square)

### Содержание
* [Сборка и запуск проекта](#сборка-и-запуск-проекта)
  + [Шаг 0. Минимальные требования](#шаг-0-минимальные-требования)
  + [Шаг 1. Компиляция](#шаг-1-компиляция)
  + [Шаг 2. Наполнение базы данных](#шаг-2-наполнение-базы-данных)
    - [Шаг 2.1. Подготовка файла в формате JSON](#шаг-21-подготовка-файла-в-формате-json)
    - [Шаг 2.2. Запуск программы](#шаг-22-запуск-программы)
  + [Шаг 3. Обработка запросов](#шаг-3-обработка-запросов)
    - [Шаг 3.1. Подготовка файла в формате JSON](#шаг-31-подготовка-файла-в-формате-json)
    - [Шаг 3.2. Запуск программы](#шаг-32-запуск-программы)
    - [Шаг 3.3. Обработка результатов](#шаг-33-обработка-результатов)
* [Планы по улучшению](#планы-по-улучшению)

## Сборка и запуск проекта
> **ВАЖНО!**
> Инструкция подготовлена для системы Linux.

### Шаг 0. Минимальные требования
Для сборки и запуска проекта необходимы: 
* версия С++17 или выше, 
* установленная библиотека Protobuf3, 
* CMake версии 3.10 или выше.

### Шаг 1. Компиляция 
Для компиляции выполните следующую команду из корня репозитория (там же, где находится файл `README.md`)
```
mkdir build
cd build
cmake ../transport-catalogue -DCMAKE_PREFIX_PATH="path-to-protobuf-library"
cmake --build .
```
В переменную `-DCMAKE_PREFIX_PATH` подставьте значение полного пути к установленной библиотеке protobuf.

> **ВАЖНО!**
> Все дальнейшие шаги предполагают, что вы находитесь в папке `build` (там же, где лежит скомпилированный файл `transport_catalogue`).

### Шаг 2. Наполнение базы данных
#### Шаг 2.1. Подготовка файла в формате JSON
Создайте файл `make_base.json`, содержащий массив инструкций по наполнению базы данных.
Добавьте в файл следующие секции:
```
{
    "serialization_settings": {},
    "routing_settings": {},
    "render_settings": {},
    "base_requests": []
}
```

Ниже дана подробная информация о содержимом секций (значения даны для примера и могут быть изменены).

**Название для файла базы данных**
```
"serialization_settings": {
    "file": "transport_catalogue.db"
}
```
* `file` хранит название файла базы данных

**Параметры для нахождения кратчайшего пути**
```
"routing_settings": {
    "bus_wait_time": 2,
    "bus_velocity": 30
}
```
* `bus_wait_time` хранит время ожидания автобуса на остановке (в минутах).<br>
* `bus_velocity` хранит название скорость автобуса (в км/ч).

**Параметры графического отображения** 
```
"render_settings": {
    "width": 1200,
    "height": 500,
    "padding": 50,
    "stop_radius": 5,
    "line_width": 14,
    "bus_label_font_size": 20,
    "bus_label_offset": [ 7, 15],
    "stop_label_font_size": 18,
    "stop_label_offset": [7,-3],
    "underlayer_color": [255, 255, 255, 0.85],
    "underlayer_width": 3,
    "color_palette": ["green", [255, 160, 0], [0, 160, 255, 1]]
}
```
* `width` и `height` задают ширину и высоту холста соответственно.
* `padding` задает отступы от краев холста до изображения.
* `stop_radius` задает радиус точки, символизирующей остановку.
* `line_width` задает толщину линии автобусных маршрутов.
* `bus_label_font_size` и `stop_label_font_size` задают размер шрифта для названий автобусов и остановок соответственно.
* `bus_label_offset` и `stop_label_offset` задают координаты смещения для названий автобусов и остановок соответственно.
* `underlayer_color` и `underlayer_width` задают цвет и толщину контура для текстовых подписей.
* `color_palette` задает список цветов, чередующихся для отображения различных маршрутов.
  
Цвета могут быть заданы в формате: 
+ строки с названием цвета,
+ RGB (3 вещественных числа, задающих код цвета в виде целого числа от 0 до 255),
+ RGBA (см. RGB и 4-е вещественное число от 0 до 1, задающее прозрачность, где 1 - полность непрозрачный объект, 0 - полностью прозрачный)

**Добавление автобусов и остановок**

Запросы на добавление представляют массив информации об остановках и автобусах. Объектов в массиве может быть произвольное количество, они могут располагаться в произвольном порядке, но необходимо чтобы были добавлены все остановки, использующиеся в маршрутах (в примере ниже для краткости опущено описание остановки "Ривьерский мост"). 
```
"base_requests": [
    {
        "type": "Bus",
        "name": "114",
        "stops": [ "Морской вокзал", "Ривьерский мост"],
        "is_roundtrip": false
    },
    {
        "type": "Stop",
        "name": "Морской вокзал",
        "latitude": 43.581969,
        "longitude": 39.719848,
        "road_distances": {
            "Ривьерский мост": 850
        }
    }
]
```
* `type` может иметь 2 значения: `Bus` и `Stop`. Указывает на принадлежность блока к описанию автобуса или остановки соответственно.
  
Описание ключей для запроса типа `Bus`:
* `name` задает название маршрута.
* `stops` задает массив названий остановок, входящих в маршрут. Остановки указываются в той же последовательности, в которой их проходит автобус.
* `is_roundtrip` указывает на закольцованность маршрута. 
  
Описание ключей для запроса типа `Stop`:
* `name` задает название остановки.
* `latitude` и `longitude` задают координаты остановки
* `road_distances` задает расстояние в метрах до других остановок.

#### Шаг 2.2. Запуск программы
Запустите в консоли команду:
```
./transport_catalogue make_base <make_base.json
```
В результате выполнения будет создан файл базы данных, содержащий информацию из файла `make_base.json` в бинарном виде. Его название будет совпадать с указанным именем в JSON-запросе.

### Шаг 3. Обработка запросов
#### Шаг 3.1. Подготовка файла в формате JSON
Создайте файл `process_requests.json`: 
```
{
    "serialization_settings": {
        "file": "transport_catalogue.db"
    },
    "stat_requests": [
        {
            "id": 80146768,
            "type": "Bus",
            "name": "13"
        },
        {
            "id": 1571442892,
            "type": "Stop",
            "name": "Морской вокзал"
        },
        {
            "id": 1490699931,
            "type": "Route",
            "from": "Пансионат Нева",
            "to": "Улица Лысая Гора"
        },
        {
            "id": 684758285,
            "type": "Map"
        }
    ]
}
```
Секция `serialization_settings` обязательна и хранит название базы данных (должно совпадать с именем, указанныа в файле `make_base.json`) 

Секция `stat_requests` содержит произвольный массив запросов. Каждый запрос обязан имет поля `id` (идентификатор запроса) и `type` (тип запроса).

Поддерживаются следующие типы запросов:

**Bus**

Получить информацию об автобусе
```
{
    "id": 80146768,
    "type": "Bus",
    "name": "13"
}
```
* `name` задает название автобуса.


**Stop**

Получить информацию об остановке
```
{
    "id": 1571442892,
    "type": "Stop",
    "name": "Морской вокзал"
}
```
* `name` задает название остановки.

**Route**

Постройть кратчайший маршрут между двумя остановками.
```
{
    "id": 1490699931,
    "type": "Route",
    "from": "Пансионат Нева",
    "to": "Улица Лысая Гора"
}
```
* `from` и `to` задают названия остановок отправления и прибытия.

**Map**

Получить графическое отображение транспортной схемы в формате SVG
```
{
    "id": 684758285,
    "type": "Map"
}
```


#### Шаг 3.2. Запуск программы
Запустите в консоли команду:
```
./transport_catalogue process_requests <process_requests.json >output.json
```
В результате выполнения ответы на запросы будут записаны в выходной файл `output.json`

#### Шаг 3.3. Обработка результатов.
Выходной файл содержит массив ответов на запросы. Все ответы имеют обязательное поле `request_id`, содержащее идентификатор запроса. 

Типы ответов соответствуют типам запросов и хранят следующие данные:

**Bus**
```
{
    "curvature": 1.26723,
    "request_id": 80146768,
    "route_length": 5540,
    "stop_count": 7,
    "unique_stop_count": 4
}
```
* `curvature` - искривление маршрута. Отношение реальной длины маршрута к сумме расстояний между остановками.
* `route_length`- длина маршрута в метрах.
* `stop_count` и `unique_stop_count` - общее количество остановок по пути следования и количество уникальных остановок.

**Stop**
```
{
    "buses": [
        "23",
        "36"
    ],
    "request_id": 1571442892
}
```
* `buses` - массив названий автобусов, проходящих через остановку.

**Route**
```
{
    "items": [
        {
            "stop_name": "Морской вокзал",
            "time": 2,
            "type": "Wait"
        },
        {
            "bus": "114",
            "span_count": 1,
            "time": 1.7,
            "type": "Bus"
        },
    "request_id": 1964680131,
    "total_time": 15.96
}
```
* `total_time` - общее время в секундах, затраченное на маршрут.
* `items` - массив, описывающий построенный маршрут. Элементы могут быть двух типов `type`:
  + `Wait` - ожидание на остановке,
    - `stop_name` - название остановки,
    - `time` - время ожидания.
  + `Bus` - езда на автобусе,
    - `bus` - название автобуса,
    - `span_count` - количество остановок, которое необходимо проехать,
    - `time` - время поездки.
  

**Map**
```
{
    "map": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <polyline points=\"100.817,170 30,30 100.817,170\" fill=\"none\" stroke=\"green\" stroke-width=\"14\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"green\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"30\" y=\"30\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"green\" x=\"30\" y=\"30\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <circle cx=\"100.817\" cy=\"170\" r=\"5\" fill=\"white\"/>\n  <circle cx=\"30\" cy=\"30\" r=\"5\" fill=\"white\"/>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Морской вокзал</text>\n  <text fill=\"black\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Морской вокзал</text>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"30\" y=\"30\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Ривьерский мост</text>\n  <text fill=\"black\" x=\"30\" y=\"30\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Ривьерский мост</text>\n</svg>",
    "request_id": 1359372752
}
```

## Планы по улучшению
* Задать в map_renderer.cpp черный цвет по умолчанию для отрисовки маршрутов, если массив цветов пуст или не указан в JSON.
* Добавить отлов исключений в main.cpp c выводом понятного текста ошибки, например, если в JSON не указано название базы данных.
* В файле json.cpp в теле функтора `NodePrinter(const Dict & arr)` заменить прямой вывод ключа на вызов `PrintNode(key, context)`, чтобы корректно выводить экранированные символы
